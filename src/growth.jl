##/usr/bin/env julia
# Linear Growth Factor, g(z)=D(z)(1+z), which is constant and equal to 
# unity during the matter dominated era. Also computes its derivative 
# with respect to lna, dg/dlna.
# 
# *** Radiation density is ignored in the calculation ***
#
# << sample code >>
#
# USE cosmo
# USE growth
# double precision :: g,dgdlna,redshift
# external g,dgdlna
# # Specify three cosmological parameters in double precision.
# # The data type has been defined in MODULE cosmo.
# ode0=0.723
# om0=0.277
# w   = -1
# CALL setup_growth
# redshift=10
# print*,'omega matter=',om0
# print*,'omega de=',ode0
# print*,'w=',w
# print*,'g(z) at z=',redshift,'is',g(redshift)
# print*,'dg/dlna(z) at z=',redshift,'is',dgdlna(redshift)
# end
#
# August 23, 2008
# E. Komatsu
#

module Growth

export setup_growth

struct GrowthFactor
end


function setup_growth()
    nw = 501
    xa = fill(NaN, nw)
    ga = fill(NaN, nw)
    g2a = fill(NaN, nw)
    dga = fill(NaN, nw)
    dg2a = fill(NaN, nw)

    # tabulate g(x), where x=ln(a)
    y = fill(NaN, 2)
    c = fill(NaN, 24)
    work = fill(NaN, 2, 9)
    tol = 1e-8

    ind = 1 
    for i=1:nw
        x = (i-nw)*0.01 # x=ln(a)=-5.00,-4.99,...,0
        xa[i] = x
        if i == 1
            xini = xa[i]
            y[1] = 1 # initial condition, g=1, at z=-5.00 (z=147.413)
            y[2] = 0 # initial condition, g'=1, at z=-5.00 (z=147.413)
        else
            dverk(2,fderiv,xini,y,x,tol,ind,c,2,work)
            xini = x
        end
        ga[i] = y[1]
        dga[i]= y[2]
    end
    spline(xa,ga,nw,1e30,1e30,g2a)  # evaluate g2a(i)=d^2[g(i)]/dy^2
    spline(xa,dga,nw,1e30,1e30,dg2a)# evaluate g2a(i)=d^2[dg/dlna(i)]/dy^2
    return
end
#-----------------------------------------------------------------------------
function fderiv(n,x,y,yprime)
# x = ln(a) = -ln(1+z)
# y(1) = g
# y(2) = g'
# See Eq.(76) of Komatsu et al. (2008) [WMAP 5-year]
  or0 = 0 # ignore radiation density
  z=exp(-x)-1
  a=exp(x)
  ok0=1-om0-ode0
  h2=om0/a^3+or0/a^4+ok0/a^2+ode0/a^(3*(1+w))
  ok=ok0/h2*exp(-2*x)
  ode=ode0/h2*exp(-3*x*(1+w)) 
  yprime[1]= y[2] 
  yprime[2]= (-(2.5+0.5*(ok-3*w*ode))*y(2)
              -(2*ok+1.5*(1-w)*ode)*y[1])
  return
end
#-----------------------------------------------------------------------------
function g(z)
  # Returns g(z) = D(z)(1+z) by interpolating the table generated by
  # Setup_Growth. 
  x=-log(1+z) # x=ln(a)=-ln(1+z)
  if x==0
     g=ga(nw)
  else
     hunt(xa,nw,x,jlo)
     hh=xa(jlo+1)-xa(jlo)
     a=(xa(jlo+1)-x)/hh
     b=(x-xa(jlo))/hh
     g=a*ga(jlo)+b*ga(jlo+1)+((a^3-a)*g2a(jlo)+(b^3-b)*g2a(jlo+1))*(hh^2)/6.
  end
  return
end
#-----------------------------------------------------------------------------
function dgdlna(z)
  # Returns dg/dlna(z) by interpolating the table generated by
  # Setup_Growth.
  x=-log(1+z) # x=ln(a)=-ln(1+z)
  if x==0
     dgdlna=dga(nw)
  else
     hunt(xa,nw,x,jlo)
     hh=xa(jlo+1)-xa(jlo)
     a=(xa(jlo+1)-x)/hh
     b=(x-xa(jlo))/hh
     dgdlna=a*dga(jlo)+b*dga(jlo+1)+((a^3-a)*dg2a(jlo)+(b^3-b)*dg2a(jlo+1))*(hh^2)/6.
  end
  return
end

end
# vim: sw=4 et sts=4 :
